/**
 * Copyright (C) 2012 Red Hat, Inc. (jcasey@redhat.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.commonjava.maven.ext.manip.impl;

import org.apache.maven.project.MavenProject;
import org.commonjava.maven.ext.manip.ManipulationException;
import org.commonjava.maven.ext.manip.ManipulationSession;
import org.commonjava.maven.ext.manip.model.Project;
import org.commonjava.maven.ext.manip.state.State;
import org.commonjava.maven.ext.manip.state.VersioningState;
import org.commonjava.maven.ext.manip.util.IdUtils;

import java.util.List;
import java.util.Set;

/**
 * Represents one way that a POM may be manipulated/modified during pre-processing. State is kept separately for each {@link Manipulator}
 * (see {@link VersioningState}, associated with the {@link ProjectVersioningManipulator} implementation of this interface). State is stored in the
 * {@link ManipulationSession} instance. State consists of both configuration (normally detected from the user properties, or -D options on the command
 * line), and also changes detected in the scan() method invocation that will be applied later.
 *
 * @author jdcasey
 */
public interface Manipulator
{

    /**
     * Initialize any state for the manipulator. States are stored via
     * {@link ManipulationSession#setState(State)} during this method's invocation,
     * for later use in the other methods of this interface.
     *
     * @param session the session to initialise with.
     * @throws ManipulationException if an error occurs.
     */
    void init( ManipulationSession session )
        throws ManipulationException;

    /**
     * Pre-scan the list of {@link Project} instances for changes that should be made BEFORE any of the changes are actually applied. This allows
     * for changes to references between projects, for example.
     *
     * @param projects the current list of Projects.
     * @param session the current container session.
     * @throws ManipulationException if an error occurs.
     */
    void scan( final List<Project> projects, ManipulationSession session )
        throws ManipulationException;

    /**
     * Apply any changes to the raw models (stored in the {@link ManipulationSession} related to the given list of {@link MavenProject} instances
     * (related by GAV string, generated by {@link IdUtils#gav(MavenProject)}.
     *
     * @param projects the Projects to apply the changes to.
     * @param session the container session.
     * @return the set of changed projects.
     * @throws ManipulationException if an error occurs.
     */
    Set<Project> applyChanges( List<Project> projects, ManipulationSession session )
        throws ManipulationException;

    /**
     * In some cases, manipulators may need to take a look
     * at the final changes after they are applied.
     * However, no further manipulation is allowed at this point.
     * This is the counterpart to the {@link Manipulator#scan(List, ManipulationSession)}
     * method.
     *
     * @param projects the Projects to apply the changes to.
     * @param session the container session.
     * @throws ManipulationException if an error occurs.
     */
    void afterApplyChanges( List<Project> projects, ManipulationSession session )
                    throws ManipulationException;

    /**
     * Determines the order in which manipulators are run, with the lowest number running first.
     * Uses a 100-point scale.
     * @return current index.
     */
    int getExecutionIndex();

}
